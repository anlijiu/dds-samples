## soa 接口定义

用rti编译为 libSoaDataTypes.a


| IDL Type | Example Entry in IDL File| RTI Code Generate Example |
|----------|--------------------------|---------------------------|
char     |  char member;    | <code>char member() const OMG_NOEXCEPT;<br> void member(char value); </code>
wchar    |  wchar member;  | <code>DDS_Wchar member() const OMG_NOEXCEPT;<br>void member(DDS_Wchar value);</code>
octet    |  octet member;  | <code>uint8_t member() const OMG_NOEXCEPT;<br>void member(uint8_t value);</code>
short    |  short member;  | <code>int16_t member() const OMG_NOEXCEPT;<br>void member(int16_t value);</code>
unsigned short    |  unsigned short member;  | <code>int16_t member() const OMG_NOEXCEPT;<br>void member(int16_t value);</code>
long     |  long member; | <code>int32_t member() const OMG_NOEXCEPT;<br>void member(int32_t value);</code>
unsigned long     |  unsigned long member; | <code>uint32_t member() const OMG_NOEXCEPT;<br>void member(uint32_t value);</code>
long long | long long member; | <code>rti::core::int64 member() const OMG_NOEXCEPT;<br>void member(rti::core::int64 value);</code>
unsigned long long | unsigned long long member;| <code>rti::core::uint64 member);<br>rti::core::uint64 member() const OMG_NOEXCEPT;</code>
float | float member; | <code>float member() const OMG_NOEXCEPT; <br> void member(float value);</code>
double | double member; | <code>double member() const OMG_NOEXCEPT; <br>void double_member(double value); </code>
long double | long double member; |<code>rti::core::LongDouble& member() OMG_NOEXCEPT; <br> const rti::core::LongDouble& member() const OMG_NOEXCEPT; <br>void member(const rti::core::LongDouble& value); </code>
pointer | long * member; | <code> int32_t * member() const OMG_NOEXCEPT; <br> void member(int32_t * value); </code>
boolean | boolean member;| <code>bool boolean_member() const OMG_NOEXCEPT; <br> void boolean_member(bool value); </code>
enum | <pre>enum PrimitiveEnum {<br>    ENUM1,<br>    ENUM2, <br>    ENUM3<br>}; <br><p>enum PrimitiveEnum {<br>    ENUM1 = 10,<br>    ENUM2 = 20,<br>    ENUM3 = 30<br>};</pre> | <pre><code>struct PrimitiveEnum_def {<br>    enum type {<br>        ENUM1,<br>        ENUM2,<br>        ENUM3<br>    };<br>}; <br>typedef dds::core::safe_enum<PrimitiveEnum_def> PrimitiveEnum;<br>struct PrimitiveEnum_def {<br>    enum type {<br>        ENUM1 = 10,<br>        ENUM2 = 20,<br>        ENUM3 = 30<br>    };<br>};<br>typedef dds::core::safe_enum<PrimitiveEnum_def> PrimitiveEnum;</code></pre>
constant|const short SIZE = 5;| static const int16_t SIZE = 5;
struct | char char_member; |char char_member() const OMG_NOEXCEPT; <br> void char_member(char value);
union | <pre><code>union PrimitiveUnion switch (long){<br>    case 1:<br>        short short_member;<br>    default:<br>         long long_member;<br>};</code></pre>|<pre><code>class PrimitiveUnion {<br>public:<br>    int32_t _d() const ;<br>    void _d(int32_t value);<br>    int16_t short_member() const ;<br>    void short_member(int16_t value);<br>    int32_t long_member() const ;<br>    void long_member(int32_t value);<br>    static int32_t default_discriminator();<br>private:<br>    int32_t m_d_;<br>    struct Union_ {<br>    int16_t m_short_member_;<br>    int32_t m_long_member_;<br>    Union_();<br>    Union_(<br>        int16_t short_member,<br>        int32_t long_member);<br>    };<br>    Union_ m_u_;<br>};</code></pre>
typedef|typedef short TypedefShort;|typedef int16_t TypedefShort;<br> struct TypedefShort_AliasTag_t {};
array of above types|<pre>struct OneDArrayStruct {<br>    short short_array[2];<br>};</pre>|<pre><code>struct TwoDArrayStruct {<br>   short short_array[1][2];<br>};<br>class OneDArrayStruct {<br>public:<br>    dds::core::array<int16_t, 2>& short_array() OMG_NOEXCEPT;<br>    const dds::core::array<int16_t, 2>& short_array() const OMG_NOEXCEPT;<br>    void short_array(const dds::core::array<int16_t, 2>& value);<br>};<br><br>class TwoDArrayStruct {<br>public:<br>    dds::core::array<dds::core::array<int16_t, 2>, 1>& short_array() OMG_NOEXCEPT;<br>    const dds::core::array<dds::core::array<int16_t, 2>, 1>& short_array() const OMG_NOEXCEPT;<br>    void short_array(const dds::core::array<dds::core::array<int16_t, 2>, 1>& value);<br>};<br></code></pre>
bounded sequence of above types|<pre>struct SequenceStruct {<br>   sequence<short,4> short_sequence;<br>};<br></pre>|<pre>class SequenceStruct {<br>public:<br>    dds::core::vector<int16_t>& short_sequence() OMG_NOEXCEPT;<br>    const dds::core::vector<int16_t>& short_sequence() const OMG_NOEXCEPT;<br>    void short_sequence(const dds::core::vector<int16_t>& value);<br>};<br></pre>
unbounded sequence of above types|<pre>struct SequenceStruct {<br>   sequence<short> short_sequence;<br>};</pre>|<pre>class SequenceStruct {<br>public:<br>    dds::core::vector<int16_t>& short_sequence() OMG_NOEXCEPT;<br>    const dds::core::vector<int16_t>& short_sequence() const OMG_NOEXCEPT;<br>    void short_sequence(const dds::core::vector<int16_t>& value);<br>};</pre>
array of sequences|<pre>struct ArraysOfSequences{<br>   sequence<short,4><br>       sequences_array[2];<br>};<br></pre>|<pre>class ArraysOfSequences {<br>public:<br>    dds::core::array<dds::core::vector<int16_t>, 2>& sequences_array() OMG_NOEXCEPT;<br>    const dds::core::array<dds::core::vector<int16_t>, 2>& sequences_array() const OMG_NOEXCEPT;<br>    void sequences_array(const dds::core::array<dds::core::vector<int16_t>, 2>& value);<br>};</pre>
sequence of arrays|<pre>typedef short ShortArray[2];<br>struct SequenceofArrays {<br>   sequence<ShortArray,2>     <br>       arrays_sequence;<br>};<br></pre>|<pre>typedef dds::core::array<int16_t, 2> ShortArray;<br>class SequenceofArrays {<br>public:<br>    dds::core::vector<ShortArray>& arrays_sequence() OMG_NOEXCEPT;<br>    const dds::core::vector<ShortArray>& arrays_sequence() const OMG_NOEXCEPT;<br>    void arrays_sequence(const dds::core::vector<ShortArray>& value);<br>};</pre>
sequence of sequences|<pre>typedef sequence<short,4><br>    ShortSequence;<br><br>struct SequencesOfSequences{<br>    sequence<ShortSequence,2><br>        sequences_sequence;<br>};</pre> |<pre>typedef dds::core::vector<int16_t> ShortSequence;<br><br>class SequencesOfSequences {<br>public:<br>    dds::core::vector<ShortSequence>& sequences_sequence() OMG_NOEXCEPT;<br>    const dds::core::vector<ShortSequence>& sequences_sequence() const OMG_NOEXCEPT;<br>    void sequences_sequence(const dds::core::vector<ShortSequence>& value);<br>};</pre>
bounded string|<pre>struct PrimitiveStruct {<br>   string<20> string_member;<br>};</pre>|<pre>class PrimitiveStruct {<br>public:<br>    dds::core::string& string_member() OMG_NOEXCEPT;<br>    const dds::core::string& string_member() const OMG_NOEXCEPT;<br>    void string_member(const dds::core::string& value);<br>};</pre>
unbounded string|<pre>struct PrimitiveStruct {<br>    string string_member;<br>};</pre>|<pre>class PrimitiveStruct {<br>public:<br>    dds::core::string& string_member() OMG_NOEXCEPT;<br>    const dds::core::string& string_member() const OMG_NOEXCEPT;<br>    void string_member(const dds::core::string& value);<br>};</pre>
bounded wstring|<pre>struct PrimitiveStruct {<br>    wstring<20> wstring_member;<br>};</pre> |<pre>class PrimitiveStruct {<br>public:<br>    dds::core::wstring& wstring_member() OMG_NOEXCEPT;<br>    const dds::core::wstring& wstring_member() const OMG_NOEXCEPT;<br>    void wstring_member(const dds::core::wstring& value);<br>};</pre>
unbounded wstring|<pre>struct PrimitiveStruct {<br>    wstring wstring_member;<br>};</pre> |<pre>class PrimitiveStruct {<br>public:<br>    dds::core::wstring& wstring_member() OMG_NOEXCEPT;<br>    const dds::core::wstring& wstring_member() const OMG_NOEXCEPT;<br>    void wstring_member(const dds::core::wstring& value);<br>};</pre>
module | <pre>module PackageName {<br>    struct Foo {<br>        long field;<br>    };<br>};</pre> |<pre>namespace PackageName {<br>    class Foo {<br>    public:<br>        int32_t field() const OMG_NOEXCEPT;<br>        void field(int32_t value);<br>    };<br>};</pre>
valuetype|<pre>valuetype MyBaseValueType  {<br>    public long  member;<br>};<br><br>valuetype MyValueType:<br>MyBaseValueType  {<br>    public short * member2;<br>};</pre> |<pre>class MyBaseValueType {<br>public:<br>    int32_t member() const OMG_NOEXCEPT;<br>    void member(int32_t value);<br>};<br><br>class MyValueType : public MyBaseValueType {<br>public:<br>    int16_t * member2() const OMG_NOEXCEPT;<br>    void member2(int16_t * value);<br>};</pre>
